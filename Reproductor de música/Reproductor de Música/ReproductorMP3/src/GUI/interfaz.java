/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package GUI;

import java.awt.Image;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.DefaultListModel;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javazoom.jlgui.basicplayer.BasicController;
import javazoom.jlgui.basicplayer.BasicPlayer;
import javazoom.jlgui.basicplayer.BasicPlayerEvent;
import javazoom.jlgui.basicplayer.BasicPlayerException;
import javazoom.jlgui.basicplayer.BasicPlayerListener;
import utils.ListenerBotonDosPosiciones;
import utils.ListenerBotones;
import com.mpatric.mp3agic.ID3v2;
import com.mpatric.mp3agic.InvalidDataException;
import com.mpatric.mp3agic.Mp3File;
import com.mpatric.mp3agic.UnsupportedTagException;
import org.jaudiotagger.audio.AudioFile;
import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
import org.jaudiotagger.tag.Tag;
import org.jaudiotagger.tag.TagException;

/**
 *
 * @author Alejandro Ureña Marín
 * @author Manuel García López
 * 
 * Esta es la interfaz de clase que gestiona el entorno gráfico del reproductor 
 * de música multimedia.
 * 
 */
public class interfaz extends javax.swing.JFrame {
    
    /*Variable de memoria. Son usadas para almacenar meoria de carácter temporal.
     */
    File file = null;
    BasicPlayer player;
    BasicPlayerListener playerListener;
    ArrayList<File> canciones;
    ArrayList<Integer> aleatorias;
    
    /**
     * Variables de opciones gráficas, las cuales usamos de apoyo para representar 
     * estados dinámicos como la duración actual de la canción, el progreso de la 
     * canción o el balance de audio.
     */
    String duration, progress;
    double volumen = 0.5;
    double balance = 0;
    int posicionAleatoria = 0;
    
    /**
     * Booleanos que irán indicando si se activan o desactivan los parámetros de 
     * repetir canción y reproducir en aleatorio.
     */
    boolean repetir = false;
    boolean aleatorio = false;
    
    //Variable para saber distinguir cuando para el usuario o cuando para porque llega el slider al final.
    boolean noReiniciar = false;

    /**
     * Constructor de la interfaz: Genera una nueva interfaz.
     * Inicialización de componentes.
     */
    public interfaz() {
        initComponents();
        
        canciones = new ArrayList();
        aleatorias = new ArrayList();
        
        player = new BasicPlayer();
        
        addBasicPlayerListener();
        addVolumenListener();
        addBalanceListener();
        addDuracionListener();
        addListaListener();
        
        new ListenerBotones(botonPlay, "play.png", "play2.png", "Reproducir");
        new ListenerBotones(botonPause, "pause.png", "pause2.png", "Pausar");
        new ListenerBotones(botonStop, "stop.png", "stop2.png", "Parar");
        new ListenerBotones(botonNext, "next.png", "next2.png", "Siguiente");
        new ListenerBotones(botonPrevious, "previous.png", "previous2.png", "Anterior");
        new ListenerBotones(botonBuscar, "path.png", "path2.png", "Elige una ruta");
        new ListenerBotones(botonEliminar, "delete.png", "delete2.png", "Elimina cancion elegida");
        new ListenerBotones(botonAnadir, "add.png", "add2.png", "Añadir canciones de la ruta");
        
        new ListenerBotonDosPosiciones(botonRepetir, "repeat.png", "repeat2.png", "repeatpressed.png", "repeatpressed2.png", "Repetir");
        new ListenerBotonDosPosiciones(botonMute, "mute.png", "mute2.png", "mutepressed.png", "mutepressed2.png", "Sin sonido");
        new ListenerBotonDosPosiciones(botonAleatorio, "random.png", "random2.png", "randompressed.png", "randompressed2.png", "Aleatorio");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        imagen = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        lista = new javax.swing.JList<>();
        botonPlay = new javax.swing.JButton();
        botonPause = new javax.swing.JButton();
        botonStop = new javax.swing.JButton();
        botonNext = new javax.swing.JButton();
        botonPrevious = new javax.swing.JButton();
        bal = new javax.swing.JLabel();
        vol = new javax.swing.JLabel();
        barraVolumen = new javax.swing.JSlider();
        barraDuracion = new javax.swing.JSlider();
        jLabel4 = new javax.swing.JLabel();
        progreso = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        duracion = new javax.swing.JLabel();
        botonBuscar = new javax.swing.JButton();
        botonEliminar = new javax.swing.JButton();
        ruta = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        botonAnadir = new javax.swing.JButton();
        barraBalance = new javax.swing.JSlider();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        botonRepetir = new javax.swing.JToggleButton();
        botonMute = new javax.swing.JToggleButton();
        botonAleatorio = new javax.swing.JToggleButton();
        titulocancion = new javax.swing.JLabel();
        titulo = new javax.swing.JLabel();
        albumcancion = new javax.swing.JLabel();
        album = new javax.swing.JLabel();
        autorcancion = new javax.swing.JLabel();
        autor = new javax.swing.JLabel();
        aniocancion = new javax.swing.JLabel();
        anio = new javax.swing.JLabel();
        fondo = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Reproductor MP3");

        jPanel1.setBackground(new java.awt.Color(0, 0, 0));
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        imagen.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/defaultPhoto.png"))); // NOI18N
        jPanel1.add(imagen, new org.netbeans.lib.awtextra.AbsoluteConstraints(390, 40, 250, 250));

        lista.setBackground(new java.awt.Color(153, 153, 153));
        lista.setForeground(new java.awt.Color(0, 0, 255));
        lista.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane1.setViewportView(lista);

        jPanel1.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 40, 290, 370));

        botonPlay.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/play2.png"))); // NOI18N
        botonPlay.setBorderPainted(false);
        botonPlay.setContentAreaFilled(false);
        botonPlay.setFocusable(false);
        botonPlay.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonPlayActionPerformed(evt);
            }
        });
        jPanel1.add(botonPlay, new org.netbeans.lib.awtextra.AbsoluteConstraints(250, 480, 40, 40));

        botonPause.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/pause2.png"))); // NOI18N
        botonPause.setBorderPainted(false);
        botonPause.setContentAreaFilled(false);
        botonPause.setFocusable(false);
        botonPause.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonPauseActionPerformed(evt);
            }
        });
        jPanel1.add(botonPause, new org.netbeans.lib.awtextra.AbsoluteConstraints(190, 480, 40, 40));

        botonStop.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/stop2.png"))); // NOI18N
        botonStop.setBorderPainted(false);
        botonStop.setContentAreaFilled(false);
        botonStop.setFocusable(false);
        botonStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonStopActionPerformed(evt);
            }
        });
        jPanel1.add(botonStop, new org.netbeans.lib.awtextra.AbsoluteConstraints(130, 480, 40, 40));

        botonNext.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/next2.png"))); // NOI18N
        botonNext.setBorderPainted(false);
        botonNext.setContentAreaFilled(false);
        botonNext.setFocusable(false);
        botonNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonNextActionPerformed(evt);
            }
        });
        jPanel1.add(botonNext, new org.netbeans.lib.awtextra.AbsoluteConstraints(370, 480, 40, 40));

        botonPrevious.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/previous2.png"))); // NOI18N
        botonPrevious.setBorderPainted(false);
        botonPrevious.setContentAreaFilled(false);
        botonPrevious.setFocusable(false);
        botonPrevious.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonPreviousActionPerformed(evt);
            }
        });
        jPanel1.add(botonPrevious, new org.netbeans.lib.awtextra.AbsoluteConstraints(310, 480, 40, 40));

        bal.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        bal.setForeground(new java.awt.Color(255, 255, 255));
        bal.setText("0.0");
        jPanel1.add(bal, new org.netbeans.lib.awtextra.AbsoluteConstraints(760, 490, 30, -1));

        vol.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        vol.setForeground(new java.awt.Color(255, 255, 255));
        vol.setText("50");
        jPanel1.add(vol, new org.netbeans.lib.awtextra.AbsoluteConstraints(760, 390, -1, -1));

        barraVolumen.setBackground(new java.awt.Color(0, 0, 153));
        barraVolumen.setForeground(new java.awt.Color(0, 0, 255));
        barraVolumen.setOpaque(false);
        jPanel1.add(barraVolumen, new org.netbeans.lib.awtextra.AbsoluteConstraints(580, 420, -1, -1));

        barraDuracion.setValue(0);
        barraDuracion.setEnabled(false);
        barraDuracion.setOpaque(false);
        jPanel1.add(barraDuracion, new org.netbeans.lib.awtextra.AbsoluteConstraints(80, 550, 520, -1));

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("L");
        jPanel1.add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(570, 460, 10, -1));

        progreso.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        progreso.setForeground(new java.awt.Color(255, 255, 255));
        progreso.setText("00:00:00");
        jPanel1.add(progreso, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 560, -1, -1));

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setText("/");
        jPanel1.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(670, 560, 10, -1));

        duracion.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        duracion.setForeground(new java.awt.Color(255, 255, 255));
        duracion.setText("00:00:00");
        jPanel1.add(duracion, new org.netbeans.lib.awtextra.AbsoluteConstraints(680, 560, -1, -1));

        botonBuscar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/path2.png"))); // NOI18N
        botonBuscar.setBorderPainted(false);
        botonBuscar.setContentAreaFilled(false);
        botonBuscar.setFocusable(false);
        botonBuscar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonBuscarActionPerformed(evt);
            }
        });
        jPanel1.add(botonBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(340, 310, 40, 40));

        botonEliminar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/delete2.png"))); // NOI18N
        botonEliminar.setBorderPainted(false);
        botonEliminar.setContentAreaFilled(false);
        botonEliminar.setFocusable(false);
        botonEliminar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonEliminarActionPerformed(evt);
            }
        });
        jPanel1.add(botonEliminar, new org.netbeans.lib.awtextra.AbsoluteConstraints(340, 360, 40, 40));

        ruta.setEditable(false);
        ruta.setText("Ruta");
        ruta.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rutaActionPerformed(evt);
            }
        });
        jPanel1.add(ruta, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 420, 290, 20));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel1.setText("Canciones");
        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 10, -1, -1));

        botonAnadir.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/add2.png"))); // NOI18N
        botonAnadir.setBorderPainted(false);
        botonAnadir.setContentAreaFilled(false);
        botonAnadir.setFocusable(false);
        botonAnadir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonAnadirActionPerformed(evt);
            }
        });
        jPanel1.add(botonAnadir, new org.netbeans.lib.awtextra.AbsoluteConstraints(340, 410, 40, 40));

        barraBalance.setMinimum(-100);
        barraBalance.setValue(0);
        barraBalance.setOpaque(false);
        jPanel1.add(barraBalance, new org.netbeans.lib.awtextra.AbsoluteConstraints(580, 460, -1, -1));

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel6.setForeground(new java.awt.Color(255, 255, 255));
        jLabel6.setText("R");
        jPanel1.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(780, 460, -1, -1));

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(255, 255, 255));
        jLabel7.setText("Duración:");
        jPanel1.add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 540, -1, -1));

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel8.setForeground(new java.awt.Color(255, 255, 255));
        jLabel8.setText("Volumen: ");
        jPanel1.add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(700, 390, -1, -1));

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel9.setForeground(new java.awt.Color(255, 255, 255));
        jLabel9.setText("Balance:");
        jPanel1.add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(700, 490, -1, -1));

        botonRepetir.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/repeat2.png"))); // NOI18N
        botonRepetir.setBorderPainted(false);
        botonRepetir.setContentAreaFilled(false);
        botonRepetir.setFocusable(false);
        botonRepetir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonRepetirActionPerformed(evt);
            }
        });
        jPanel1.add(botonRepetir, new org.netbeans.lib.awtextra.AbsoluteConstraints(430, 480, 40, 40));

        botonMute.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/mute2.png"))); // NOI18N
        botonMute.setBorderPainted(false);
        botonMute.setContentAreaFilled(false);
        botonMute.setFocusable(false);
        botonMute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonMuteActionPerformed(evt);
            }
        });
        jPanel1.add(botonMute, new org.netbeans.lib.awtextra.AbsoluteConstraints(650, 380, 40, 40));

        botonAleatorio.setIcon(new javax.swing.ImageIcon(getClass().getResource("/botones/random2.png"))); // NOI18N
        botonAleatorio.setBorderPainted(false);
        botonAleatorio.setContentAreaFilled(false);
        botonAleatorio.setFocusable(false);
        botonAleatorio.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonAleatorioActionPerformed(evt);
            }
        });
        jPanel1.add(botonAleatorio, new org.netbeans.lib.awtextra.AbsoluteConstraints(490, 480, 40, 40));

        titulocancion.setText("Titulo de la cancion:");
        jPanel1.add(titulocancion, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 50, -1, -1));

        titulo.setForeground(java.awt.Color.white);
        jPanel1.add(titulo, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 80, -1, -1));

        albumcancion.setText("Album de la cancion:");
        jPanel1.add(albumcancion, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 110, -1, -1));

        album.setForeground(java.awt.Color.white);
        jPanel1.add(album, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 150, -1, -1));

        autorcancion.setText("Autor de la cancion:");
        jPanel1.add(autorcancion, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 180, -1, -1));

        autor.setForeground(java.awt.Color.white);
        jPanel1.add(autor, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 210, -1, -1));

        aniocancion.setText("Año de la cancion:");
        jPanel1.add(aniocancion, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 240, -1, -1));

        anio.setForeground(java.awt.Color.white);
        jPanel1.add(anio, new org.netbeans.lib.awtextra.AbsoluteConstraints(660, 270, -1, -1));

        fondo.setBackground(new java.awt.Color(0, 0, 0));
        fondo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/fondos/azul.png"))); // NOI18N
        jPanel1.add(fondo, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Función utilizada para capturar la acción del botón de stop de la interfaz,
     * este botón es usado para detener la ejecución de una canción.
     * @param evt 
     */
    private void botonStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonStopActionPerformed
        // TODO add your handling code here:
        /**
         * Obtenemos el estado actual del jugador, si este es igual a estado de 
         * ejecución o de pausa, detendremos la ejecución.
         */
        int status = player.getStatus();
        if(status == BasicPlayer.PAUSED || status == BasicPlayer.PLAYING){
            try {
                noReiniciar= true;
                player.stop();
            } catch (BasicPlayerException ex) {
                
            }
        }
    }//GEN-LAST:event_botonStopActionPerformed

    /**
     * Función utilizada para capturar la acción del botón de play de la interfaz,
     * este botón es usado para ejecutar la ejecución de una canción desde el inicio
     * de la misma si ha estado previamente parada. En caso de haber estado en pausa, 
     * simplemente continuará con la ejecución habitual de la canción hasta ese 
     * momento seleccionada
     * @param evt 
     */
    private void botonPlayActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonPlayActionPerformed
        // TODO add your handling code here:
        /**
         * Obtenemos el estado actual del jugador, si este es igual a estado de 
         * de pausa, continuaremos con la ejecución.
         */
        int status = player.getStatus();
        if(status == BasicPlayer.PAUSED){
            try {
                player.setGain(volumen);
                player.setPan(balance);
                player.resume();
            } catch (BasicPlayerException ex) {
                
            }
        }
        /**
         * En caso de ser estado de parada, ejecutaremos una canción desde el principio
         */
        if(status == BasicPlayer.STOPPED){
            try {
                player.setGain(volumen);
                player.setPan(balance);
                player.play();
            } catch (BasicPlayerException ex) {
                
            }
        }
    }//GEN-LAST:event_botonPlayActionPerformed

    /**
     * Función utilizada para capturar la acción del botón de pause de la interfaz,
     * este botón es usado para pausar la ejecución de una canción en cualquier 
     * momento, si el usuario así lo desea.
     * @param evt 
     */
    private void botonPauseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonPauseActionPerformed
        // TODO add your handling code here:
        /**
         * Obtenemos el estado actual del jugador, si este es igual a estado de 
         * de ejecución, pausaremos dicha ejecución.
         */
        if(player.getStatus() == BasicPlayer.PLAYING){
            try {
                player.pause();
            } catch (BasicPlayerException ex) {
            }
        }
    }//GEN-LAST:event_botonPauseActionPerformed

    /**
     * Función utilizada para capturar la acción del botón de siguiente de la interfaz,
     * este botón es usado para pasar de canción, siempre que el usuario lo estime oportuno, 
     * al reproducir la acción la canción en marcha se dentendrá, y se producirá el cambio 
     * de canción, para comenzar la reproducción de la siguiente canción desde el inicio.
     * @param evt 
     */
    private void botonNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonNextActionPerformed
        // TODO add your handling code here:
        /**
         * Para pasar a la siguiente canción, debemos comprobar los parámetros 
         * de reproducción, a saber, aleatorio o repetición. 
         * En caso de ser aleatorio: calcularemos una posición aleatoria del vector 
         * de canciones que estamos reproduciendo actualmente.
         * En caso de estar activado repetir: desactivamos dicha opción, de lo contrario, 
         * la canción se reproducirá constantemente.
         * En caso de no estar activado ninguna de las opciones anteriores simplemente 
         * pasará a la siguiente canción.
         */
        if(repetir){
            repetir = false;
            botonRepetir.setSelected(false);
            botonRepetir.setIcon(new ImageIcon(getClass().getResource("/botones/repeat2.png")));
        }
        
        if(aleatorio){
            int posAleatorio = (int)(Math.random()*100*canciones.size())%canciones.size();
            siguienteCancion(posAleatorio);
        }else{
            siguienteCancion(1);
        }
    }//GEN-LAST:event_botonNextActionPerformed

    /**
     * Función utilizada para capturar la acción del botón de anterior de la interfaz,
     * este botón es usado para pasar de canción, siempre que el usuario lo estime oportuno, 
     * al reproducir la acción la canción en marcha se dentendrá, y se producirá el cambio 
     * de canción, para comenzar la reproducción de la siguiente canción desde el inicio.
     * @param evt 
     */
    private void botonPreviousActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonPreviousActionPerformed
        // TODO add your handling code here:
        /**
         * Para pasar a la anterior canción, nuevamente debemos comprobar los parámetros 
         * de reproducción, a saber, aleatorio o repetición. 
         * En caso de ser aleatorio: calcularemos una posición aleatoria del vector 
         * de canciones que estamos reproduciendo actualmente.
         * En caso de estar activado repetir: desactivamos dicha opción, de lo contrario, 
         * la canción se reproducirá constantemente.
         * En caso de no estar activado ninguna de las opciones anteriores simplemente 
         * pasará a la anterior canción.
         */
        if(repetir){
            repetir = false;
            botonRepetir.setSelected(false);
            botonRepetir.setIcon(new ImageIcon(getClass().getResource("/botones/repeat2.png")));
        }
        
        if(aleatorio){
            int posAleatorio = (int)(Math.random()*100*canciones.size())%canciones.size();
            siguienteCancion(posAleatorio);
        }else{
            siguienteCancion(-1);
        }
    }//GEN-LAST:event_botonPreviousActionPerformed
    
    /**
     * Función utilizada para buscar las canciones dada una ruta del ordenador 
     * seleccionada por el usuario
     * @param evt 
     */
    private void botonBuscarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonBuscarActionPerformed
        // TODO add your handling code here:
        /**
         * Creamos el objeto de tipo JFileChooser, el cual servirá para identificar 
         * los distintos archivos y directorios presentes en la ruta introducida
         */
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
        
        /**
         * En caso de estar todo correcto, obtendremos la ruta del archivo, y 
         * en caso de este terminar en .mp3, lo añadiremos al JPanel de canciones 
         * en nuestra lista de reproducción. En caso contrario, el archivo será 
         * descartado, y se lanzará un mensaje de error.
         */
        if(fileChooser.showOpenDialog(fileChooser) == JFileChooser.APPROVE_OPTION){
            file = fileChooser.getSelectedFile();
            
            if(file.isDirectory()){
                ruta.setText(file.getAbsolutePath());
            }else{
                if(file.getName().endsWith(".mp3")){
                    ruta.setText(file.getAbsolutePath());
                }else{
                    JOptionPane.showMessageDialog(null, "El archivo seleccionado no es MP3.");
                }
            }
        }else{
            JOptionPane.showMessageDialog(null, "No ha elegido ningún archivo MP3 o directorio..");
        }
    }//GEN-LAST:event_botonBuscarActionPerformed

    /**
     * Función utilizada para eliminar una canción de la lista actual de canciones, 
     * esto hará que durante la reproducción de dicha lista, las canciones eliminadas
     * no sean tenidas más en cuenta
     * @param evt 
     */
    private void botonEliminarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonEliminarActionPerformed
        // TODO add your handling code here:
        /**
         * Todas las funcionalidades de eliminar serán tenidas en cuenta siempre 
         * y cuando, la lista de canciones, no esté vacía, y exista alguna canción 
         * seleccionada para ser borrada. 
         * En caso de que el estado de la reproducción fuese alguno de los conocidos.
         * y la canción borrada, fuese la única canción disponible en la lista de canciones,
         * se procederá a detener la posible ejecución del hilo, y a resetear los valores 
         * de ejecución gráfica. Finalmente, se elimina la canción de la lista, y se 
         * recarga la vista del JPanel además de volver a permitirse la selección de una 
         * nueva cacnción.
         */
        if(!canciones.isEmpty()){
            if(!lista.isSelectionEmpty()){
                int index = lista.getAnchorSelectionIndex();
                
                //Comprobamos si es la ultima cancion que borramos o no.
                if(canciones.size() > 1){
                    siguienteCancion(1);
                }else if(canciones.size() == 1){
                    if(player.getStatus() != BasicPlayer.UNKNOWN){
                        try {
                            noReiniciar = true;
                            player.stop();
                            ruta.setText("Ruta");
                            duracion.setText("00:00:00");
                        } catch (BasicPlayerException ex) {
                        }
                    }
                }
                
                canciones.remove(index);
                
                mostrarListaCanciones();
                
                selecionarLista();
            }
        }
    }//GEN-LAST:event_botonEliminarActionPerformed

    private void rutaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rutaActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_rutaActionPerformed

    /**
     * Esta función establece la posibilidad de añadir una canción o directorio 
     * completo a la lista de canciones a reproducir, esto, nos permitiría hacer
     * inclusiones a gran escala de canciones.
     * @param evt 
     */
    private void botonAnadirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonAnadirActionPerformed
        // TODO add your handling code here:
        /**
         * Para realizar dicha función, debemos comprobar si el archivo actual es 
         * correcto, si es una canción o si es un directorio, y finalmente añadir 
         * cadda una de esas canciones o canción a nuestro array de canciones. 
         * Finalmente, mistraremos todas las canciones en nuestro JPanel.
         */
        if(file != null){
            if(file.isDirectory()){
                for(String archivo : file.list()){
                    if(archivo.endsWith(".mp3")){
                        File arch = new File(file.getAbsolutePath()+ "\\" +archivo);
                        boolean add = true;
                        for(int i = 0; i < canciones.size(); i++){
                            if(canciones.get(i).getAbsolutePath().equals(arch.getAbsolutePath())){
                                add = false;
                                break;
                            }
                        }
                        if(add){
                            canciones.add(arch);
                        }
                    }
                }
                mostrarListaCanciones();
            }else{
                boolean add = true;
                for(int i = 0; i < canciones.size(); i++){
                    if(canciones.get(i).getAbsolutePath().equals(file.getAbsolutePath())){
                        add = false;
                        break;
                    }
                }
                if(add){
                    canciones.add(file);
                    mostrarListaCanciones();
                }
            }
        }
    }//GEN-LAST:event_botonAnadirActionPerformed

    /**
     * Esta función es la controladora de la acción de repetir, la cual será llamada 
     * cada vez que se pulse en el botón de repetir, e irá cambiando de estados en 
     * función de si previamente estaba seleccionado o no.
     * @param evt 
     */
    private void botonRepetirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonRepetirActionPerformed
        // TODO add your handling code here:
        if(botonRepetir.isSelected()){
            repetir = true;
            /**
             * En caso de desactivar el aleatorio, cambiamos también su vista en
             * la interfaz.
             */
            if(aleatorio){
                aleatorio = false;
                botonAleatorio.setSelected(false);
                botonAleatorio.setIcon(new ImageIcon(getClass().getResource("/botones/random2.png")));
            }
        }else{
            repetir = false;
        }
    }//GEN-LAST:event_botonRepetirActionPerformed

    /**
     * Función que al ser llamada corta el audio de la canción, la canción se sigue 
     * reproduciendo con su curso habitual, pero dejará de escucharse volumen alguno.
     * @param evt 
     */
    private void botonMuteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonMuteActionPerformed
        // TODO add your handling code here:
        /**
         * Como siempre, hemos de comprobar que el boton de audio silenciado o mute, 
         * esté activado o no, si está activado, el volumen pasará a ser cero.
         * En caso de que el botón se haya pulsado para desactivar esta opción,
         * el volumen se pondrá por defecto a 50 (la mitad de la potencia) en caso de
         * no encontrarse ninguna canión en reproducción. En caso de estar alguna
         * en reproducción, el volumen retomará su valor anterior. 
         * Estos cambios serán reflejados por la barra de volumen para ser más visuales.
         */
        if(botonMute.isSelected()){
            //Comprobamos si el player esta abierto o no.
            if(player.getStatus() == BasicPlayer.UNKNOWN){
                volumen = 0;
            }else{
                try {
                    volumen = 0;
                    player.setGain(volumen);
                } catch (BasicPlayerException ex) {
                    Logger.getLogger(interfaz.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }else{
            //Comprobamos si el player esta abierto o no.
            if(player.getStatus() == BasicPlayer.UNKNOWN){
                volumen = 50;
            }else{
                try {
                    volumen = barraVolumen.getValue()/100.0;
                    player.setGain(volumen);
                } catch (BasicPlayerException ex) {
                    Logger.getLogger(interfaz.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }//GEN-LAST:event_botonMuteActionPerformed

    /**
     * Esta función, maneja la selección de las siguientes canciones dentro del 
     * flujo actual de reproducción, gracias al botón de aleatorio. En caso de 
     * estar dicho botón activado, se pondrá la variable booleana a true, y cuando 
     * se llame a siguienteCancion(),la canción seleccionada será la de una posición
     * random. Sin embargo, si el botón se desactiva o no está seleccionado, 
     * el bool se pone a false y al llamar a siguienteCancion() se seleccionará 
     * la siguiente canción wue exista en la lista de reproducción.
     * @param evt 
     */
    private void botonAleatorioActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonAleatorioActionPerformed
        // TODO add your handling code here:
        /**
         * Como cada vez que usamos los controladores de aleatorio y repetición/
         * bucle, necesitaremos comprobar si el antagónico está activado, para así
         * poder desactivarlo cada vez que se active el otro, esto es así por 
         * decisión propia nuestra, ya que no queremos que una canción se pueda 
         * reproducir infinitas veces si está en modo aleatorio, solo por el hecho
         * de haber pulsado antes en repetir.
         */
        if(botonAleatorio.isSelected()){
            aleatorio = true;
            //Ponemos boton repetir a false.
            if(repetir){
                repetir = false;
                botonRepetir.setSelected(false);
                botonRepetir.setIcon(new ImageIcon(getClass().getResource("/botones/repeat2.png")));
            }
        }else{
            aleatorio = false;
        }
    }//GEN-LAST:event_botonAleatorioActionPerformed

    /**
     * Esta función, es la encargada de resetear las canciones que se muestran
     * por pantalla en el JPanel de nuestra aplicación. De tal forma que cada vez
     * que se inserta o se elimina una cacnción, se hará la correspondiente 
     * llamada a esta función para refrescar la información del panel de 
     * reproducción.
     */
    private void mostrarListaCanciones(){
        
        /**
         * Cargamos el modelo por defecto del listado de canciones, y para cada
         * elemento que tengamos disponible en el array de canciones actuales, 
         * lo vamos insertando en dicho modelo. Dicho array, es el se modifica 
         * con las inserciones y borrados de las canciones, para después 
         * llamar a esta función.
         * Finalmente hacemos display del modelo para mostrar la actualización 
         * por pantalla.
         */
        DefaultListModel<String> listModel = new DefaultListModel();
        
        for(int i = 0; i < canciones.size(); i++){
            listModel.addElement(canciones.get(i).getName());
        }
        
        if(listModel.isEmpty()){
            listModel.addElement("");
        }
        
        lista.setModel(listModel);
    }
    
    /**
     * Esta función es la principal de nuestra interfaz, es la encargada de 
     * controlar la ejecución de la aplicación, y de todos sus elementos, 
     * barras de volumen, de progreso, estado de reproducción de las canciones
     * en ejecución, y llamadas a siguienteCanción() o anteriorCancion(), en 
     * función de los booleanos de control y su estado.
     */
    private void addBasicPlayerListener() {
        /**
         * Creamos el nuevo controlador de reproducción.
         */
        playerListener = new BasicPlayerListener() {
            
            /**
             * Comprobamos que nos llega un nuevo objeto, en tal caso, resetearemos
             * a cero las variables correspondientes de duración y barraDuración.
             * 
             * @param o
             * @param map 
             */
            @Override
            public void opened(Object o, Map map) {
                duration = map.get("duration").toString();
                
                barraDuracion.setMinimum(0);
                barraDuracion.setMaximum(Integer.parseInt(map.get("mp3.length.bytes").toString()));
                
                duracion.setText(nanoSecsToString(Integer.parseInt(duration)));
                if(barraDuracion.getValue() == 0){
                    progreso.setText("00:00:00");
                }
            }

            /**
             * En caso de la barra de progreso, resetear dicha barra a cero, no 
             * es suficiente, también deberemos calcular el tiempo máximo de 
             * duración de la canción que comenzará a reproducirse en este instante,
             * y colocar dicho tiempo como uno de los parámetros de la barra, para
             * así hacer más visual, el tiempo restante de la canción mientras
             * esta se reproduce.
             * 
             * @param i
             * @param l
             * @param bytes
             * @param map 
             */
            @Override
            public void progress(int i, long l, byte[] bytes, Map map) {
                
                progress = map.get("mp3.position.byte").toString();
                
                int bytePosition = Integer.parseInt(progress);
                barraDuracion.setValue(bytePosition);
                
                calcularProgreso(duration, String.valueOf(barraDuracion.getMaximum()), map.get("mp3.position.byte").toString());
                
            }

            /**
             * A continuación calcularemos (en caso de que la canción se detenga
             * por llegar al final), la posible canción que vaya a ser reproducida 
             * a continuación, y en función de las distintas variables de control, 
             * llamaremos a siguienteCanción() con:
             * Cero, si la canción se va a repetir.
             * Uno, si la canción a reproducir es la siguiente en la lista.
             * Aleatorio, si la reproducción está en modo aleatorio.
             * @param bpe 
             */
            @Override
            public void stateUpdated(BasicPlayerEvent bpe) {
                if(player.getStatus() == BasicPlayer.STOPPED){
                    
                    barraDuracion.setValue(0);
                    progreso.setText("00:00:00");
                    
                    //Variable que nos indica si ha sido el usuario el que ha parado o el propio slider.
                    if(!noReiniciar){
                        noReiniciar = false;
                        barraDuracion.setValue(barraDuracion.getMaximum());
                        if(repetir){
                            siguienteCancion(0);
                        }else if(aleatorio){
                            int posAleatorio = (int)(Math.random()*100*canciones.size())%canciones.size();
                            siguienteCancion(posAleatorio);
                        }else{
                            siguienteCancion(1);
                        }
                    }
                }
            }

            @Override
            public void setController(BasicController bc) {
                
            }
        };
        
        player.addBasicPlayerListener(playerListener);
    }
    
    /**
     * Esta función, es la encargada de ajustar el volumen cada vez que el volumen
     * es tocado por el usuario mediante la barra o el boton de volumen del sistema.
     */
    public void addVolumenListener(){
        barraVolumen.addChangeListener(new ChangeListener() {
            
            /**
             * Para ello, resetearemos el botón de mute (volumen = cero) a false,
             * una vez habiendo deshabilitado este botón, calcularemos el volumen
             * exacto en el que se ha quedado volumen interno del sistema, y lo 
             * reflejaremos en la barra de volumen de nuestra interfaz
             * @param e 
             */
            
            @Override
            public void stateChanged(ChangeEvent e) {
                botonMute.setSelected(false);
                botonMute.setIcon(new ImageIcon(getClass().getResource("/botones/mute2.png")));
                
                vol.setText(String.valueOf(barraVolumen.getValue()));
                volumen = barraVolumen.getValue()/100.0;
                
                try {
                    player.setGain(volumen);
                } catch (BasicPlayerException ex) {
                }
            }
        });
    };
    
    /**
     * Otra barra controladora importante, es la barra de balance de volumen,
     * la cual es capaz de distribuir el volumen entre el altavoz derecho e izquierdo.
     */
    public void addBalanceListener(){
        barraBalance.addChangeListener(new ChangeListener() {
            
            /**
             * Nuevamente, calcularemos automáticamente la posición en la que se 
             * está quedando la barra de balance, realizamos un tanto por ciento 
             * para establecer un valor exacto, y reseteamos la visualización de 
             * dicha barra
             * @param e 
             */
            
            @Override
            public void stateChanged(ChangeEvent e) {
                bal.setText(String.valueOf(barraBalance.getValue()/100.0));
                balance = barraBalance.getValue()/100.0;
                
                try {
                    player.setPan(balance);
                } catch (BasicPlayerException ex) {
                }
            }
        });
    };
    
    /**
     * Finalmente, el último de los controles de usuario, es la barra de duración,
     * dicha barra, tendrá una serie de funciones de control de ratón, a diferencia 
     * de los anteriores, los cuales se podían usar simplemente haciendo un click de
     * ratón en la barra, en este caso, la mayoría de usuarios, en la barra de duración, 
     * no sueltan el click del ratón hasta que se situan sobre un segundo de la 
     * reproducción en concreto.
     */
    public void addDuracionListener(){
        barraDuracion.addMouseListener(new MouseAdapter() {
            
            /**
             * La primera función será al clicar el ratón lo que hará será detener 
             * temporalmente la ejecución de la canción.
             * @param e 
             */
            
            @Override
            public void mousePressed(MouseEvent e){
                try{
                    if(player.getStatus() == BasicPlayer.PLAYING){
                        player.pause();
                    }
                }catch(BasicPlayerException ex){
                }
            }
            
            /**
             * Y esta función, que se ejecutará al soltar el ratón, será la que 
             * finalmente busque el segundo adecuado de la canción, en el cual
             * seguirá automaticamente la reproducción de la canción nada más 
             * soltar el ratón.
             * @param e 
             */
            
            @Override
            public void mouseReleased(MouseEvent e){
                try{
                    if(player.getStatus() == BasicPlayer.PAUSED){
                        player.seek(barraDuracion.getValue());
                        player.setGain(volumen);
                        player.setPan(balance);
                        player.resume();
                    }
                    if(player.getStatus() == BasicPlayer.STOPPED){
                        player.play();
                        player.seek(barraDuracion.getValue());
                        player.setGain(volumen);
                        player.setPan(balance);
                    }
                }catch(BasicPlayerException ex){
                }
            }
        });
        
        barraDuracion.addChangeListener(new ChangeListener() {
            
            /**
             * Finalmente habrá que recalcular el progreso correspondiente de la
             * barra de duración, para nuevamente proporcionar de forma más intuitiva 
             * la parte de la canción que se está reproduciendo actualmente.
             * @param e 
             */
            
            @Override
            public void stateChanged(ChangeEvent e) {
                calcularProgreso(duration, String.valueOf(barraDuracion.getMaximum()), String.valueOf(barraDuracion.getValue()));
            }
        });
    };
    
    /**
     * Este controlador,(el cual no es realmente visual) se encarga de establecer 
     * la selección de la canción correspondiente en nuestra lista de canciones.
     * Al hacer click sobre una canción, lo cual nos indicará que efectivamente, el objeto qie se quería seleccionar,
     * se encuentra en la lista.
     */    
    public void addListaListener(){
        lista.addMouseListener(new MouseAdapter() {
            /**
             * Cuando hagamos click en la lista, obtendremos un ancla sobre la 
             * variable que hemos seleccionado, y llamaremos a la función 
             * preparar, para preparar la ejecución de dicha canción.
             * @param e 
             */
            @Override
            public void mouseClicked(MouseEvent e){
                int var = lista.getAnchorSelectionIndex();
                if(var != -1){
                    preparar(var);
                }
            }
        });
    };
    
    /**
     * Esta función, es la encargada de traducir el tiempo obtenido del ordenador,
     * (en nano segundos) y la pasará a formato string para que se vusualize 
     * correctamente en la barra de progreso. Esta función, se llama constantemente,
     * para poder ir refrescando el progreso temporal de la canción en reproducción.
     * 
     * @param nanoSecs
     * @return 
     */
    public String nanoSecsToString(int nanoSecs){
        
        double segundos = Math.ceil(nanoSecs/1000000.0);
        int horas = 0, minutos = 0;
        
        String stringHor, stringMin, stringSeg;
        
        if(segundos > 3600){
            horas = (int) (segundos / 3600);
            segundos = segundos - (horas * 3600);
        }
        
        if(segundos > 60){
            minutos = (int) (segundos / 60);
            segundos = segundos - (minutos * 60);
        }
        
        if(horas < 10){
            stringHor = "0" + String.valueOf(horas);
        }else{
            stringHor = String.valueOf(horas);
        }
        
        if(minutos < 10){
            stringMin = "0" + String.valueOf(minutos);
        }else{
            stringMin = String.valueOf(minutos);
        }
        
        if(segundos < 10){
            stringSeg = "0" + String.valueOf((int)segundos);
        }else{
            stringSeg = String.valueOf((int)segundos);
        }
        
        return stringHor + ":" + stringMin + ":" + stringSeg;
    }
    
    /**
     * Esta función es la encargada de recibir los datos de posición actual de 
     * la reproducción de la canción, y de mostrar dicha posición el la barra de
     * progreso.
     * 
     * @param lengthNano
     * @param lengthBytes
     * @param actualByte 
     */
    public void calcularProgreso(String lengthNano, String lengthBytes, String actualByte){
        
        int nanoSecs = (int) Math.ceil((Double.parseDouble(lengthNano) * Double.parseDouble(actualByte)) / Double.parseDouble(lengthBytes));
        
        progreso.setText(nanoSecsToString(nanoSecs));
    }
    
    /**
     * Preparar, es otra de las funciones esenciales en el flujo de reproducción 
     * de la aplicación, es la que se encarga de abrir el archivo en el que se 
     * encuentra la canción a reproducir actualmente, y de establecer el controlador
     * de la barra de duración, y de progreso de la canción a cero.
     * 
     * @param index 
     */
    public void preparar(int index){
        
        /**
         * Detenemos una posible ejecución de una canción en caso de que nuestro 
         * reproductor, se encuentre en un estado desconocido.
         */                
        if(player.getStatus() != BasicPlayer.UNKNOWN){
            try {
                noReiniciar= true;
                player.stop();
            } catch (BasicPlayerException ex) {
            }
        }
        
        /**
         * A continuación, añadiremos al controlador de la reproducción, la canción
         * que vamos a preparar para reproducir. Después, extraeremos los metadatos 
         * necesarios, junto a la carátula, siempre y cuando la tenga, comprobamos
         * el volumen y el balance de sonido, y ejecutamos la reproducción de la 
         * canción.
         */
        try {

            player.open(canciones.get(index));

            //Colocar la caratula.
            extraerMetadatosYCaratula(canciones.get(index).toString());

            ruta.setText(canciones.get(index).getAbsolutePath());

            barraDuracion.setEnabled(true);
            barraDuracion.setValue(0);
            progreso.setText("00:00:00");
            
            player.play();
            player.setGain(volumen);
            player.setPan(balance);

        } catch (BasicPlayerException ex) {
        } catch (IOException ex) {
            Logger.getLogger(interfaz.class.getName()).log(Level.SEVERE, null, ex);
        }
    };
    
    /**
     * @param index
     * 
     * Funcion que se encarga de calcular la posición de la siguiente canción 
     * a reproducir.
     * Posicion de la cancion actual + index.
     */
    public void siguienteCancion(int index){
        
        /**
         * En caso de que las canciones se encuentren por encima de la primera
         * posición del array de canciones, calcularemos la nueva posición de la
         * canción a reproducir, siempre estableciendo dicha posición dentro de
         * los límites de tamaño del array de canciones.
         * 
         * Finalmente llamamos a preparar.
         * 
         * En caso contrario, si desconocemos el estado de reproducción de la 
         * canción, detenemos la ejecución del reproductor.
         */
        if(canciones.size() > 0){
            
            int posicion = estaEnPlaylist();
            
            //Comprobamos que la cancion se encuentra en nuestra playlist.
            if(posicion != -1){
                //Calculamos la posicion de la nueva cancion a reproducir.
                if(posicion + index == -1){
                    posicion = canciones.size()-1;
                }else{
                    posicion = (posicion + index)%canciones.size();
                }
                
                lista.setSelectedIndex(posicion);
                
                preparar(posicion);
            }
        }else{
            if(player.getStatus() != BasicPlayer.UNKNOWN){
                try {
                    player.stop();
                } catch (BasicPlayerException ex) {
                }
            }
        }
        
    }
    
    /**
     * @return -1 o la posicion de la cancion.
     * 
     * Funcion que comprueba si la canción que se ha seleccionado, está en la
     * playlist, si está devuelve su posición, sino, devuelve -1.
     */
    public int estaEnPlaylist(){
        int posicion = -1;
        
        for(int i = 0; i < canciones.size(); i++){
            if(canciones.get(i).getAbsolutePath().equals(ruta.getText())){
                posicion = i;
                break;
            }
        }        
        return posicion;
    }
    
    /**
     * Funcion que sobresalta en la lista la cancion que esta reproduciendose.
     */
    public void selecionarLista(){
        
        int index = estaEnPlaylist();
        
        if(index != -1){
            lista.setSelectedIndex(index);
        }
    }
    
    /*
    public int cancionAleatoria(int posicion){
        if(aleatorias.size() > 0){
            //Calculamos la posicion de la nueva cancion a reproducir.
            posicion = (posicion+1)%aleatorias.size();
            int posicionReal = aleatorias.get(posicion);
            //Ponemos la ruta y el fichero a los datos de lo que tenemos que reproducir.
            file = canciones.get(posicionReal);
            try {
                //Paramos reproduccion y llamamos a iniciar para preparar el reproductor.
                player.stop();
                //iniciar();
            } catch (BasicPlayerException ex) {
            }            
        }
        return posicion;
    }*/
    
    /**
     * Función encargada de generar una lista de reproducción de formato aleatorio,
     * a partir de nuestro array de canciones actuales.
     */
    
    private void crearListaAleatoria() {
        posicionAleatoria = 0;
        aleatorias.clear();
        boolean yaInsertado = false;
        int intAleatorio = 0;
        Random aleatorio;
        for(int i=0; i<canciones.size();++i){
            while(yaInsertado){
                aleatorio = new Random(System.currentTimeMillis());
                intAleatorio = aleatorio.nextInt(canciones.size());
                for(int j=0; j<aleatorias.size();++j){
                    if(aleatorias.get(j)==intAleatorio){
                        yaInsertado = true;
                    }
                }
                if(!yaInsertado){
                    yaInsertado = false;
                    aleatorias.add(intAleatorio);
                }
            }            
        }
    }
    
    /**
     * Esta función se encarga de obtener los metadatos y la carátula asociadas 
     * a cada canción, en el momento en que alguna de estas se vaya a reproducir.
     * @param rut
     * @throws IOException 
     */
    public void extraerMetadatosYCaratula(String rut) throws IOException{  
        
        /**
         * Para realizar esto, usaremos un objeto Mp3File, suponiendo que todo 
         * archivo .mp3 incluido en la lista de canciones es internamente un .mp3,
         * a continuación, extraeremos las diversas etiquetas que trae el archivo,
         * de las cuales obtendremos los datos de: título, álbum, autor, y año,
         * además intentaremos extraer la carátula correspondiente a cada canción.
         * En caso de no poseer la canión ninguna carátula, se hará el display de 
         * una carátula por defecto.
         * Esta carátula se seleccionará como icono, lo cual nos permitirá también 
         * reajustar el tamaño de la imagen.
         */
        Image img = null;   
        try { 
            Mp3File Mp3A = new Mp3File(rut);
            if (Mp3A.hasId3v2Tag()){
                ID3v2 idTag = Mp3A.getId3v2Tag();
                titulo.setText(idTag.getTitle());
                System.out.println(idTag.getTitle());
                album.setText(idTag.getAlbum());
                autor.setText(idTag.getArtist());
                anio.setText(idTag.getYear());
                byte[] datosImagen = idTag.getAlbumImage();
                img = ImageIO.read(new ByteArrayInputStream(datosImagen));	
            }
            else {  
                img = ImageIO.read(getClass().getResource("/imagenes/defaultPhoto.png"));					        
            }
        } 
        catch (IllegalArgumentException | IOException ex1){System.out.printf("No se expecifica una ruta"); }
        catch (NullPointerException e1) {System.out.println("No hay caratula en el mp3");
         
        try {
            img = ImageIO.read(getClass().getResource("/imagenes/defaultPhoto.png"));
        } 
        catch (IOException e) {}
        } 
        catch (UnsupportedTagException | InvalidDataException e) {}
        int ancho = img.getWidth(null);
        int alto = img.getHeight(null);       
        if (ancho>250){
            ancho=250;
        } 
        if (alto>250){
            alto=250;
        }
        
        img = img.getScaledInstance(ancho, alto,0);
        imagen.setIcon(new ImageIcon(img));
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel album;
    private javax.swing.JLabel albumcancion;
    private javax.swing.JLabel anio;
    private javax.swing.JLabel aniocancion;
    private javax.swing.JLabel autor;
    private javax.swing.JLabel autorcancion;
    private javax.swing.JLabel bal;
    private javax.swing.JSlider barraBalance;
    private javax.swing.JSlider barraDuracion;
    private javax.swing.JSlider barraVolumen;
    private javax.swing.JToggleButton botonAleatorio;
    private javax.swing.JButton botonAnadir;
    private javax.swing.JButton botonBuscar;
    private javax.swing.JButton botonEliminar;
    private javax.swing.JToggleButton botonMute;
    private javax.swing.JButton botonNext;
    private javax.swing.JButton botonPause;
    private javax.swing.JButton botonPlay;
    private javax.swing.JButton botonPrevious;
    private javax.swing.JToggleButton botonRepetir;
    private javax.swing.JButton botonStop;
    private javax.swing.JLabel duracion;
    private javax.swing.JLabel fondo;
    private javax.swing.JLabel imagen;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JList<String> lista;
    private javax.swing.JLabel progreso;
    private javax.swing.JTextField ruta;
    private javax.swing.JLabel titulo;
    private javax.swing.JLabel titulocancion;
    private javax.swing.JLabel vol;
    // End of variables declaration//GEN-END:variables
}
